(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{211:function(a,s,t){"use strict";t.r(s);var e=t(0),n=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"内存分配2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存分配2"}},[a._v("#")]),a._v(" 内存分配2")]),a._v(" "),t("h2",{attrs:{id:"核心思想"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#核心思想"}},[a._v("#")]),a._v(" 核心思想")]),a._v(" "),t("ol",[t("li",[a._v("每次从操作系统申请一块大内存,runtime对这块内存分配,减少系统调用")]),a._v(" "),t("li",[a._v("分配算法采用tcmalloc算法,把内存切分非常细小,分为多级管理,降低锁粒度")]),a._v(" "),t("li",[a._v("回收对象时并不释放内存,只是放回预先分配多大内存块内,便于复用,只有闲置内存过多时,才会尝试归还部分内存给操作系统,降低整体开销.")])]),a._v(" "),t("div",{staticClass:"language-go extra-class"},[t("pre",{pre:!0,attrs:{class:"language-go"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// runtime/sizeclasses.go")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// class id 每个span结构中都有一个class id表示该span可处理的对象类型")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// bytes/obj 该class代表对象的字节数")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// bytes/span 每个span占用堆字节数,即页数*页的大小(8kb)")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// objects 每个span可分配的对象个数 (bytes/span) / (bytes/obj)")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// waste bytes 每个span产生的内存碎片 (bytes/span) % (bytes/obj)")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 以类型(class)为1的span为例,span中的元素大小是8 byte,span本身占1⻚也就是8K,一共可以保存1024个对象")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 代码中一共66种,还有一种大于32k对象,直接从heap分配一个特殊的span,类型时0,只包含一个大对象,span大小由对象大小决定")]),a._v("\n")])])]),t("h2",{attrs:{id:"bitmaps"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bitmaps"}},[a._v("#")]),a._v(" bitmaps")]),a._v(" "),t("p",[a._v("作用一是标记arena中的对应地址是否有对象,而是标记对象是否被扫描过,一个功能一个bit位,所以heap bitmaps占用2个bit位,")]),a._v(" "),t("p",[a._v("管理分配角度:page连续内存块")]),a._v(" "),t("h2",{attrs:{id:"spans"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spans"}},[a._v("#")]),a._v(" spans")]),a._v(" "),t("p",[a._v("heap内存管理")]),a._v(" "),t("p",[a._v("使用角度,heap中存在的对象")]),a._v(" "),t("h3",{attrs:{id:"mspan"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mspan"}},[a._v("#")]),a._v(" mspan")]),a._v(" "),t("p",[a._v("内存管理基础单元,直接存放数据的地方,")]),a._v(" "),t("h3",{attrs:{id:"mcache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mcache"}},[a._v("#")]),a._v(" mcache")]),a._v(" "),t("p",[a._v("p级别span内存块,分配给运行中的g,同一时刻只有一个g在p上运行,所以没有锁竞争")]),a._v(" "),t("h3",{attrs:{id:"mcentral-67个"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mcentral-67个"}},[a._v("#")]),a._v(" mcentral(67个)")]),a._v(" "),t("p",[a._v("有多少类型的mspan就有多少mcentral,是全局的,会被所有mche访问,会出现并发问题,mcentral会存在一个锁")]),a._v(" "),t("h3",{attrs:{id:"mheap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mheap"}},[a._v("#")]),a._v(" mheap")])])}),[],!1,null,null,null);s.default=n.exports}}]);